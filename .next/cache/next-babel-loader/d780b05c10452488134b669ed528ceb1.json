{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _extends from \"@babel/runtime-corejs2/helpers/esm/extends\";\nimport _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime-corejs2/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime-corejs2/helpers/esm/inherits\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport axios from 'axios';\nimport React, { Fragment, Component } from 'react';\nimport { withGoogleMap, withScriptjs, GoogleMap } from 'react-google-maps';\nimport UserMarker from './UserMarker';\nimport PersonMarker from './PersonMarker';\n\nvar MapContainer =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(MapContainer, _Component);\n\n  function MapContainer() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, MapContainer);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(MapContainer)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    _defineProperty(_assertThisInitialized(_this), \"withinRegion\", function (position, radius) {\n      var to = new google.maps.LatLng(position.lat, position.lng);\n      var distance = google.maps.geometry.spherical.computeDistanceBetween;\n      return function (point) {\n        var from = new google.maps.LatLng(point.lat, point.lng);\n        return distance(from, to) <= radius;\n      };\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"analyzeRegion\", function (position, radius) {\n      return function (people) {\n        var _this$props$onRegionF = _this.props.onRegionFiltered,\n            onRegionFiltered = _this$props$onRegionF === void 0 ? function (f) {\n          return f;\n        } : _this$props$onRegionF;\n\n        var withinRegion = _this.withinRegion(position, radius);\n\n        var mappedPeople = people.map(function (person) {\n          var _ref = person || {},\n              position = _ref.position;\n\n          var within = withinRegion(position);\n          return _objectSpread({}, person, {\n            within: within\n          });\n        });\n        onRegionFiltered(mappedPeople);\n      };\n    });\n\n    return _this;\n  }\n\n  _createClass(MapContainer, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      var _this$props = this.props,\n          _this$props$person = _this$props.person,\n          id = _this$props$person.id,\n          position = _this$props$person.position,\n          radius = _this$props.radius,\n          _this$props$people = _this$props.people,\n          people = _this$props$people === void 0 ? [] : _this$props$people,\n          _this$props$channel = _this$props.channel,\n          channel = _this$props$channel === void 0 ? null : _this$props$channel;\n      var mapContext = this.map.context['__SECRET_MAP_DO_NOT_USE_OR_YOU_WILL_BE_FIRED'];\n      var setMapCenter = mapContext.setCenter.bind(mapContext);\n      var lat = position.lat,\n          lng = position.lng;\n      channel && channel.bind('transit', function (_ref2) {\n        var _ref2$person = _ref2.person,\n            person = _ref2$person === void 0 ? {} : _ref2$person,\n            people = _ref2.people;\n        var $id = person.id,\n            $position = person.position;\n        var isUser = id === $id;\n        var center = isUser ? $position : position;\n        isUser && setMapCenter(center);\n\n        _this2.analyzeRegion(center, radius)(people);\n      });\n      this.positionUpdate = setInterval(function () {\n        lat = lat + Math.random() * 0.001;\n        lng = lng + Math.random() * 0.001;\n        axios.post(\"/transit/\".concat(id), {\n          lat: lat,\n          lng: lng\n        });\n      }, 10000);\n      this.analyzeRegion(position, radius)(people);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      clearInterval(this.positionUpdate);\n    } // Here we render the GoogleMap component passing the position of the current user as the center prop. \n    // We loop through the people collection received by the MapComponent and render different types of makers based on the person.\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      var _this$props2 = this.props,\n          _this$props2$person = _this$props2.person,\n          id = _this$props2$person.id,\n          position = _this$props2$person.position,\n          radius = _this$props2.radius,\n          people = _this$props2.people,\n          channel = _this$props2.channel; // ref will give us access to the underlying google.maps.Map instance, which we will need later to update the map properties.\n      // We use UserMarker for the currently active user and the PersonMarker for other people.\n      // We also pass the radius, person and channel props to the marker components. \n      // The channel prop contains a reference to the current Pusher channel subscription.\n      // For the PersonMarker component, we pass in the currently active user to the user prop.\n      // We also pass in an inverted version of the withinRegion() method to the withinRegion prop.\n\n      return __jsx(GoogleMap, {\n        ref: function ref(elem) {\n          return _this3.map = elem;\n        },\n        zoom: 15,\n        center: position\n      }, __jsx(Fragment, null, people.map(function (person, index) {\n        var props = {\n          key: index,\n          radius: radius,\n          person: person,\n          channel: channel\n        };\n\n        var withinRegion = function withinRegion(point) {\n          return function (position, radius) {\n            return _this3.withinRegion(position, radius)(point);\n          };\n        };\n\n        return person.id === id ? __jsx(UserMarker, props) : __jsx(PersonMarker, _extends({\n          user: _this3.props.person,\n          withinRegion: withinRegion\n        }, props));\n      })));\n    }\n  }]);\n\n  return MapContainer;\n}(Component);\n\n;\nexport default withScriptjs(withGoogleMap(MapContainer));","map":null,"metadata":{},"sourceType":"module"}