{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _extends from \"@babel/runtime-corejs2/helpers/esm/extends\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport axios from 'axios';\nimport React, { Fragment, Component } from 'react';\nimport { withGoogleMap, withScriptjs, GoogleMap } from 'react-google-maps';\nimport UserMarker from './UserMarker';\nimport PersonMarker from './PersonMarker';\n\nclass MapContainer extends Component {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"withinRegion\", (position, radius) => {\n      const to = new google.maps.LatLng(position.lat, position.lng);\n      const distance = google.maps.geometry.spherical.computeDistanceBetween;\n      return point => {\n        const from = new google.maps.LatLng(point.lat, point.lng);\n        return distance(from, to) <= radius;\n      };\n    });\n\n    _defineProperty(this, \"analyzeRegion\", (position, radius) => people => {\n      const {\n        onRegionFiltered = f => f\n      } = this.props;\n      const withinRegion = this.withinRegion(position, radius);\n      const mappedPeople = people.map(person => {\n        const {\n          position\n        } = person || {};\n        const within = withinRegion(position);\n        return _objectSpread({}, person, {\n          within\n        });\n      });\n      onRegionFiltered(mappedPeople);\n    });\n  }\n\n  componentDidMount() {\n    const {\n      person: {\n        id,\n        position\n      },\n      radius,\n      people = [],\n      channel = null\n    } = this.props;\n    const mapContext = this.map.context['__SECRET_MAP_DO_NOT_USE_OR_YOU_WILL_BE_FIRED'];\n    const setMapCenter = mapContext.setCenter.bind(mapContext);\n    let {\n      lat,\n      lng\n    } = position;\n    channel && channel.bind('transit', ({\n      person = {},\n      people\n    }) => {\n      const {\n        id: $id,\n        position: $position\n      } = person;\n      const isUser = id === $id;\n      const center = isUser ? $position : position;\n      isUser && setMapCenter(center);\n      this.analyzeRegion(center, radius)(people);\n    });\n    this.positionUpdate = setInterval(() => {\n      lat = lat + Math.random() * 0.001;\n      lng = lng + Math.random() * 0.001;\n      axios.post(`/transit/${id}`, {\n        lat,\n        lng\n      });\n    }, 10000);\n    this.analyzeRegion(position, radius)(people);\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.positionUpdate);\n  } // Here we render the GoogleMap component passing the position of the current user as the center prop. \n  // We loop through the people collection received by the MapComponent and render different types of makers based on the person.\n\n\n  render() {\n    const {\n      person: {\n        id,\n        position\n      },\n      radius,\n      people,\n      channel\n    } = this.props; // ref will give us access to the underlying google.maps.Map instance, which we will need later to update the map properties.\n    // We use UserMarker for the currently active user and the PersonMarker for other people.\n    // We also pass the radius, person and channel props to the marker components. \n    // The channel prop contains a reference to the current Pusher channel subscription.\n    // For the PersonMarker component, we pass in the currently active user to the user prop.\n    // We also pass in an inverted version of the withinRegion() method to the withinRegion prop.\n\n    return __jsx(GoogleMap, {\n      ref: elem => this.map = elem,\n      zoom: 15,\n      center: position\n    }, __jsx(Fragment, null, people.map((person, index) => {\n      const props = {\n        key: index,\n        radius,\n        person,\n        channel\n      };\n\n      const withinRegion = point => (position, radius) => this.withinRegion(position, radius)(point);\n\n      return person.id === id ? __jsx(UserMarker, props) : __jsx(PersonMarker, _extends({\n        user: this.props.person,\n        withinRegion: withinRegion\n      }, props));\n    })));\n  }\n\n}\n\n;\nexport default withScriptjs(withGoogleMap(MapContainer));","map":{"version":3,"sources":["/Users/fatimaaltaf/lighthouse/google_api/realtime-geofencing-app/components/MapContainer.js"],"names":["axios","React","Fragment","Component","withGoogleMap","withScriptjs","GoogleMap","UserMarker","PersonMarker","MapContainer","position","radius","to","google","maps","LatLng","lat","lng","distance","geometry","spherical","computeDistanceBetween","point","from","people","onRegionFiltered","f","props","withinRegion","mappedPeople","map","person","within","componentDidMount","id","channel","mapContext","context","setMapCenter","setCenter","bind","$id","$position","isUser","center","analyzeRegion","positionUpdate","setInterval","Math","random","post","componentWillUnmount","clearInterval","render","elem","index","key"],"mappings":"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","sourcesContent":["import axios from 'axios';\nimport React, { Fragment, Component } from 'react';\nimport { withGoogleMap, withScriptjs, GoogleMap } from 'react-google-maps';\n\nimport UserMarker from './UserMarker';\nimport PersonMarker from './PersonMarker';\n\nclass MapContainer extends Component {\n\n  //withinRegion() method enables us to determine if a point is within a defined circular region.\n  // It takes the center and radius of the region as its arguments, and returns a function. \n  // The returned function takes a point as argument and returns if the point is in the region.\n\n  withinRegion = (position, radius) => {\n    const to = new google.maps.LatLng(position.lat, position.lng);\n    const distance = google.maps.geometry.spherical.computeDistanceBetween;\n    return point => {\n      const from = new google.maps.LatLng(point.lat, point.lng);\n      return distance(from, to) <= radius;\n    }\n  }\n\n  analyzeRegion = (position, radius) => people => {\n    const { onRegionFiltered = f => f } = this.props;\n    const withinRegion = this.withinRegion(position, radius);\n\n    const mappedPeople = people.map(person => {\n      const { position } = person || {};\n      const within = withinRegion(position);\n      return { ...person, within };\n    });\n\n    onRegionFiltered(mappedPeople);\n  }\n\n  componentDidMount() {\n\n    const { person: { id, position }, radius, people = [], channel = null } = this.props;\n    const mapContext = this.map.context['__SECRET_MAP_DO_NOT_USE_OR_YOU_WILL_BE_FIRED'];\n    const setMapCenter = mapContext.setCenter.bind(mapContext);\n\n    let { lat, lng } = position;\n\n    channel && channel.bind('transit', ({ person = {}, people }) => {\n      const { id: $id, position: $position } = person;\n      const isUser = id === $id;\n      const center = isUser ? $position : position;\n\n      isUser && setMapCenter(center);\n      this.analyzeRegion(center, radius)(people);\n    });\n\n    this.positionUpdate = setInterval(() => {\n      lat = lat + Math.random() * 0.001;\n      lng = lng + Math.random() * 0.001;\n\n      axios.post(`/transit/${id}`, { lat, lng });\n    }, 10000);\n\n    this.analyzeRegion(position, radius)(people);\n\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.positionUpdate);\n  }\n\n  // Here we render the GoogleMap component passing the position of the current user as the center prop. \n  // We loop through the people collection received by the MapComponent and render different types of makers based on the person.\n\n  render() {\n    const { person: { id, position }, radius, people, channel } = this.props;\n\n    // ref will give us access to the underlying google.maps.Map instance, which we will need later to update the map properties.\n\n    // We use UserMarker for the currently active user and the PersonMarker for other people.\n    // We also pass the radius, person and channel props to the marker components. \n    // The channel prop contains a reference to the current Pusher channel subscription.\n\n    // For the PersonMarker component, we pass in the currently active user to the user prop.\n    // We also pass in an inverted version of the withinRegion() method to the withinRegion prop.\n\n    return (\n      <GoogleMap ref={elem => this.map = elem} zoom={15} center={position}>\n        <Fragment>\n          { people.map((person, index) => {\n\n            const props = { key: index, radius, person, channel };\n            const withinRegion = point => (position, radius) => this.withinRegion(position, radius)(point);\n\n            return (person.id === id)\n              ? <UserMarker {...props} />\n              : <PersonMarker user={this.props.person} withinRegion={withinRegion} {...props} />\n\n          }) }\n        </Fragment>\n      </GoogleMap>\n    );\n  }\n\n};\n\nexport default withScriptjs(withGoogleMap(MapContainer));"]},"metadata":{},"sourceType":"module"}