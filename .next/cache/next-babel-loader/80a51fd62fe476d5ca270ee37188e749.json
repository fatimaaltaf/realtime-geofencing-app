{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _extends from \"@babel/runtime-corejs2/helpers/esm/extends\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport axios from 'axios';\nimport React, { Fragment, Component } from 'react';\nimport { withGoogleMap, withScriptjs, GoogleMap } from 'react-google-maps';\nimport UserMarker from './UserMarker';\nimport PersonMarker from './PersonMarker';\n\nclass MapContainer extends Component {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"withinRegion\", (position, radius) => {\n      const to = new google.maps.LatLng(position.lat, position.lng);\n      const distance = google.maps.geometry.spherical.computeDistanceBetween;\n      return point => {\n        const from = new google.maps.LatLng(point.lat, point.lng);\n        return distance(from, to) <= radius;\n      };\n    });\n\n    _defineProperty(this, \"analyzeRegion\", (position, radius) => people => {\n      const {\n        onRegionFiltered = f => f\n      } = this.props;\n      const withinRegion = this.withinRegion(position, radius);\n      const mappedPeople = people.map(person => {\n        const {\n          position\n        } = person || {};\n        const within = withinRegion(position);\n        return _objectSpread({}, person, {\n          within\n        });\n      });\n      onRegionFiltered(mappedPeople);\n    });\n  }\n\n  componentDidMount() {\n    const {\n      person: {\n        id,\n        position\n      },\n      radius,\n      people = [],\n      channel = null\n    } = this.props;\n    const mapContext = this.map.context['__SECRET_MAP_DO_NOT_USE_OR_YOU_WILL_BE_FIRED'];\n    const setMapCenter = mapContext.setCenter.bind(mapContext);\n    let {\n      lat,\n      lng\n    } = position;\n    channel && channel.bind('transit', ({\n      person = {},\n      people\n    }) => {\n      const {\n        id: $id,\n        position: $position\n      } = person;\n      const isUser = id === $id;\n      const center = isUser ? $position : position;\n      isUser && setMapCenter(center);\n      this.analyzeRegion(center, radius)(people);\n    });\n    this.positionUpdate = setInterval(() => {\n      lat = lat + Math.random() * 0.001;\n      lng = lng + Math.random() * 0.001;\n      axios.post(`/transit/${id}`, {\n        lat,\n        lng\n      });\n    }, 10000);\n    this.analyzeRegion(position, radius)(people);\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.positionUpdate);\n  } // Here we render the GoogleMap component passing the position of the current user as the center prop. \n  // We loop through the people collection received by the MapComponent and render different types of makers based on the person.\n\n\n  render() {\n    const {\n      person: {\n        id,\n        position\n      },\n      radius,\n      people,\n      channel\n    } = this.props; // ref will give us access to the underlying google.maps.Map instance, which we will need later to update the map properties.\n    // We use UserMarker for the currently active user and the PersonMarker for other people.\n    // We also pass the radius, person and channel props to the marker components. \n    // The channel prop contains a reference to the current Pusher channel subscription.\n    // For the PersonMarker component, we pass in the currently active user to the user prop.\n    // We also pass in an inverted version of the withinRegion() method to the withinRegion prop.\n\n    return __jsx(GoogleMap, {\n      ref: elem => this.map = elem,\n      zoom: 15,\n      center: position\n    }, __jsx(Fragment, null, people.map((person, index) => {\n      const props = {\n        key: index,\n        radius,\n        person,\n        channel\n      };\n\n      const withinRegion = point => (position, radius) => this.withinRegion(position, radius)(point);\n\n      return person.id === id ? __jsx(UserMarker, props) : __jsx(PersonMarker, _extends({\n        user: this.props.person,\n        withinRegion: withinRegion\n      }, props));\n    })));\n  }\n\n}\n\n;\nexport default withScriptjs(withGoogleMap(MapContainer));","map":null,"metadata":{},"sourceType":"module"}